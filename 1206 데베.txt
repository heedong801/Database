1206 데베

************정규화 문제 풀이

성공하고 종료 : COMMIT
실패하고 중간에 종료 : ABORT	=> 트랜잭션 철회( 트랜잭션의 원자성에 의해 )
	=> 롤백은 순서가 중요 ( 수행했던 순서 반대로 )
	=> 롤백을 하게되면 다시금 처음 상태가 되니까 일괄된 상태가 됨

동시성 제어
하나의 공유된 데이터를 여러 사용자가 업데이트를 시도할 경우

트랜잭션 : 여러 개의 서브 작업들이 모여서 이루어짐

직렬 스케쥴 : 트랜1, 트랜2 순서거나 트랜2 트랜 1 => 퍼포먼스가 떨어짐
비직렬 스케쥴 : 트랜1, 트랜2가 교차해서 수행 ( 동시수행 )
	원칙적으로 데이터베이스의 일관성이 지켜지지 못함, 후에 작업하는 트랜잭션은 비일관적인 상태에서 시작함

직렬 가능 스케쥴 : 비직렬 스케쥴 중에서 어떤 직렬 스케쥴과 결과가 같게 나오는 스케쥴	=> 퍼포먼스가 좋으면서 데이터베이스의 일관성 유지

동시성 제어 오류
갱신 손실( lost update )  : 업데이트 후 기록된 것 위에 다시 덮어씌움
오손 데이터 읽기 ( dirty read ) : 비일관된 데이터를 읽었다. Ex) 다른 트랜잭션이 수행되고 있는 데이터를 읽는 것
반복할 수 없는 읽기 ( unrepeatable read ) : 처음 읽을 때랑 두번째 읽을 때가 값이 다른 것 -> 고립성을 어김
	내가 읽었던 데이터의 값이 내가 바꾸지 않았다면 바뀌었으면 안됨

동시성 제어 기법 - 로킹
갱신할 때 : 독점 로크 ( X - Lock : Exclusive lock ) ex) 화장실 볼일 보는 사람
읽을 때 : 공유 로크 ( S - Lock : Shared lock ) ex) 화장실 손 씻는 사람

내가 만약 읽기 위해 락을 걸면 읽기 락을 걸고 읽고 나서 품.

t1, t2 순서 : 22 32
t2, t1 순서 : 21 31
자료의 순서 : 22 31
3번째 답안이 직렬 스케쥴과 값이 같아지길 바랬지만, 그렇게 나오지 않음.

2단계 로킹 프로토콜 ( 2 - phase locking protocol = 2pl)
-기존의 락을 풀지 않고 계속해서 유지함 
언제까지?
새로운 데이터를 읽을 필요가 없을 때 까지
이후에 락을 풀기 시작하면 더이상 데이터를 읽을 수 없음
-X,S lock을 종료할떄까지 잡고 있음 ( long lock ) 반대의 개념으로 Short lock이 있을 수 있음

문제 발생 ( 중간에 락을 풀다가 ABORT 발생시 )
-락을 다시 가져와야 하는데 그럴 수 없음

해결법
엄정 2단계 로킹 프로토콜
-기존과 다르게 트랜잭션을 종료할때 모든 락을 한꺼번에 풀어줌 ( 여기서 종료할 때란? 종료 하고나서 락을 푸는 것임 )
-이 놈은 직렬 스케쥴을 보장해줌
-케이스에 따라서 직렬 스케쥴이 될 수도 있음.

데드락 ( deadlock )
-내가 먼저 뭘 하기 전에 상대방이 해주길 바라는 것
-두 개 이상의 트랜잭션들이 서로 상대방이 보유하고 있는 로크를 요청하면서 기다리고 있는 상태
데드락 상태를 파악하기 위해선 전체적으로 봐야한다.
데드락이 판단이 되면 한 트랙잭션을 선택해서 철회를 시켜야 한다.

고립화 수준
-일반적으로 동시성과 일관성은 상반된 구조를 가지고 있다.
-직렬 스케쥴은 일관성이 높음
-동시성을 높이고 싶으면 고립화 수준 사용

고립화 수준 종류
-Read Uncommitted -> Read Committed -> Repeatable Read -> Serializable

Repeatable Read
단순 엄정 2단계 로킹 프로토콜만으론 팬텀문제(Unrepeatable read : 유령 현상)를 해결할 수 없음
저 문제를 제외한 모든 문제는 해결됨
Unrepeatable read문제가 발생하지 않는 다는 것은 갱신손실, 오손데이터 읽는 문제도 발생하지 않음

B, B+ 대표 차이점
-B+트리는 데이터에 대한 포인터가 리프노드에만 존재 => 범위 질의를 통한 데이터 검색이 빨라짐

Read Committed
-Unrepeatable read 문제만 발생, 그 외는 발생하지 않음

Read Uncommitted
-lost Update만 발생하지 않음.